#include <stdio.h> 
int main() { 
  int* array[3]; // 1. 포인터 배열 선언
  int a = 12, b = 24, c = 36; // 2. 변수 a, b, c 선언 후 초기화
  array[0] = &a; // 3. 포인터 array[0]에 변수 a의 주소를 할당
  array[1] = &b; // 4. 포인터 array[1]에 변수 b의 주소를 할당
  array[2] = &c; // 5. 포인터 array[2]에 변수 c의 주소를 할당
  printf("%d", *array[1] + **array + 1);
  // 6. 다음 요소들을 계산한 후 출력
  // *array[1] : 포인터 array[1]이 참조한 주소를 또다시 참조하여(역참조) *(*b), 즉 b의 값 '24'를 출력
  // **array : array 뒤에 [n]이 없으므로 자동으로 배열 array의 첫 번째 요소인 포인터 array[0]이 참조한 주소를 참조(역참조). 즉 *(*array[0]) = *(*a) = a = 12를 출력
  // 1 : 그냥 정수 1을 출력
  // 최종 결과 : 24 + 12 + 1 = 37 을 출력
}

// 문제의 핵심 포인트

// 포인터 배열을 이용해 변수의 주소를 저장한 후 값을 참조하는 문제
// 1. int* array[n] 은 정수 배열이 아닌 '포인터 배열'을 선언하는 코드. 따라서 해당 코드로 제시된 array[n]은 전부 정수가 아니라 int 타입인 '포인터'로 기능하게 됨
// 2. 배열 이름(array)만 제시될 경우 항상 해당 배열의 첫 번째 요소의 주소(array[0])를 가리킴
// 3. 이미 포인터(*)로 가리키는 주소를 포인터(*)로 한 번 더 참조할 경우 '역참조'가 이루어져, 해당 주소가 기리키는 변수의 값을 가져오게 됨
// 4. *array[n]의 경우는 포인터 array[n]이 가리키는 '값'을 가져옴(역참조), array[n]은 해당 포인터가 가리키는 요소의 '주소'를 가져옴(참조)

// 비슷한 문제가 나올 경우

// 1. int 인지 int* 인지 먼저 보고 정수 배열인지 포인터 배열인지 확인하기
// 2. 배열 이름만 나올 경우 '배열의 첫번째 요소의 주소'를 가리키는 경우를 파악하기
// 3. 배열 이름이나 인덱스(array[n])을 사용해서 값을 역참조(*array[n]) 하거나, 포인터 연산을 통해서 계산을 시작
// 4. 포인터 배열에서 각 포인터가 가리키는 값을 정확하게 파악하기
