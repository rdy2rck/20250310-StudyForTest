#include <stdio.h> 
main() { 
  char* p = "KOREA";
  printf("%s\n", p);
  printf("%s\n", p + 3);
  printf("%c\n", *p);
  printf("%c\n", *(p + 3));
  printf("%c\n", *p + 2);
}



// 풀이
main() { 
  char* p = "KOREA"; // 1. 문자열 "KOREA"의 첫 번째 문자 'K'를 가리키는 포인터 p를 선언
  printf("%s\n", p); // 2. 포인터 p가 가리키는 주소 "K"부터 시작해서 문자열 끝인 null 문자('\0')까지의 문자열을 출력 => "KOREA" 출력
  printf("%s\n", p + 3); // 3. 포인터 p가 가리키는 주소 "K"에서 3칸 더 이동한 주소 "E"에서 시작해서 null 문자('\0')까지의 문자열을 출력 => "EA" 출력
  printf("%c\n", *p); // 4. *p는 포인터 p가 가리키는 값을 의미하므로(역참조), 포인터 p가 가리키는 문자열 "KOREA"의 첫 번째 문자를 출력 => "K" 출력
  printf("%c\n", *(p + 3)); // 5. *(p + 3)은 포인터 p가 3칸 더 이동한 주소의 값을 의미하므로(역참조), 포인터 p가 3칸 더 이동한 곳의 값을 출력 => "E" 출력
  printf("%c\n", *p + 2); // 6. *p는 포인터 p가 가리키는 주소의 값을 의미하므로, p의 값인 "K"에서 ASCII 값 2를 더한 77에 해당하는 문자를 출력 => "M" 출력
}

// 문제의 핵심 포인트

// 1. char*는 '문자 포인터'로, 해당 변수로 선언된 문자열은 '포인터'로 다뤄짐. 따라서 p(변수)도 *가 붙지 않아도 자동적으로 포인터로 지정
// 2. 포인터 연산 p + n 으로 포인터를 n칸 만큼 이동할 수 있음
// 3. 문자 포인터로 선언된 변수는 자동적으로 포인터로 지정되므로, 변수에 포인터(*)가 붙을 경우 해당 변수는 역참조가 이루어짐 ex) char* p='K', p=*'K', *p = *(*'K') = 'K'
// 4. 출력 시 형식 지정사 %s를 사용할 경우 해당 포인터의 위치에서 문자열 끝까지 출력, %c를 사용할 경우 해당 포인터의 위치에 있는 문자만 출력
// 5. '문자 + 정수'를 출력해야 할 경우엔, 먼저 문자를 ASCII 코드로 변환한 다음 정수를 더하고 해당 값을 다시 ASCII 코드에 해당하는 문자로 변환 ex) 문자 'A' = ASCII 코드 '65'
